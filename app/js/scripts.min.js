/*!
 * MazeBuilder-Angular
 * My 'learn how to use' AngularJS app.
 * https://bitbucket.org/Goulie81/mazebuilder-angular.git
 * @author Chad Gloyd
 * @version 0.1.0
 * Copyright 2013. MIT licensed.
 */

/**
 * Implementing Drag and Drop functionality in AngularJS is easier than ever.
 * Demo: http://codef0rmer.github.com/angular-dragdrop/
 * 
 * @version 1.0.3
 *
 * (c) 2013 Amit Gharat a.k.a codef0rmer <amit.2006.it@gmail.com> - amitgharat.wordpress.com
 */
var jqyoui=angular.module("ngDragDrop",[]).service("ngDragDropService",["$timeout","$parse",function($timeout,$parse){this.callEventCallback=function(scope,callbackName,event,ui){if(!callbackName){return}var args=[event,ui];var match=callbackName.match(/^(.+)\((.+)\)$/);if(match!==null){callbackName=match[1];values=eval("["+match[0].replace(/^(.+)\(/,"").replace(/\)/,"")+"]");args.push.apply(args,values)}scope[callbackName].apply(scope,args)};this.invokeDrop=function(e,t,n,r){var i="",s="",o={},u={},a=null,f={},l={},c,h,p=null,d=t.scope(),v=e.scope();i=e.attr("ng-model");s=t.attr("ng-model");c=v.$eval(i);h=d.$eval(s);p=t.find("[jqyoui-draggable]:last");u=d.$eval(t.attr("jqyoui-droppable"))||[];o=v.$eval(e.attr("jqyoui-draggable"))||[];o.index=this.fixIndex(v,o,c);u.index=this.fixIndex(d,u,h);a=angular.isArray(c)?o.index:null;f=angular.isArray(c)?c[a]:c;if(angular.isArray(h)&&u&&u.index!==undefined){l=h[u.index]}else if(!angular.isArray(h)){l=h}else{l={}}if(o.animate===true){this.move(e,p.length>0?p:t,null,"fast",u,null);this.move(p.length>0&&!u.multiple?p:[],e.parent("[jqyoui-droppable]"),jqyoui.startXY,"fast",u,function(){$timeout(function(){e.css({position:"relative",left:"",top:""});p.css({position:"relative",left:"",top:""});this.mutateDraggable(v,u,o,i,s,l,e);this.mutateDroppable(d,u,o,s,f,a);this.callEventCallback(d,u.onDrop,n,r)}.bind(this))}.bind(this))}else{$timeout(function(){this.mutateDraggable(v,u,o,i,s,l,e);this.mutateDroppable(d,u,o,s,f,a);this.callEventCallback(d,u.onDrop,n,r)}.bind(this))}};this.move=function(e,t,n,r,i,s){if(e.length===0){if(s){window.setTimeout(function(){s()},300)}return false}var o=9999,u=e.offset(),a=t&&t.is(":visible");if(n===null&&t.length>0){if(t.attr("jqyoui-draggable")!==undefined&&t.attr("ng-model")!==undefined&&t.is(":visible")&&i&&i.multiple){n=t.offset();if(i.stack===false){n.left+=t.outerWidth(true)}else{n.top+=t.outerHeight(true)}}else{n=t.css({visibility:"hidden",display:"block"}).offset();t.css({visibility:"",display:a?"":"none"})}}e.css({position:"absolute","z-index":o}).css(u).animate(n,r,function(){if(s)s()})};this.mutateDroppable=function(e,t,n,r,i,s){var o=e.$eval(r);e.__dragItem=i;if(angular.isArray(o)){if(t&&t.index>=0){o[t.index]=i}else{o.push(i)}if(n&&n.placeholder===true){o[o.length-1]["jqyoui_pos"]=s}}else{$parse(r+" = __dragItem")(e);if(n&&n.placeholder===true){o["jqyoui_pos"]=s}}};this.mutateDraggable=function(e,t,n,r,i,s,o){var u=angular.equals(angular.copy(s),{}),a=e.$eval(r);e.__dropItem=s;if(n&&n.placeholder){if(n.placeholder!="keep"){if(angular.isArray(a)&&n.index!==undefined){a[n.index]=s}else{$parse(r+" = __dropItem")(e)}}}else{if(angular.isArray(a)){if(u){if(n&&n.placeholder!==true&&n.placeholder!=="keep"){a.splice(n.index,1)}}else{a[n.index]=s}}else{$parse(r+" = __dropItem")(e);if(e.$parent){$parse(r+" = __dropItem")(e.$parent)}}}o.css({"z-index":"",left:"",top:""})};this.fixIndex=function(e,t,n){if(t.applyFilter&&angular.isArray(n)&&n.length>0){var r=e[t.applyFilter](),i=r[t.index],s=undefined;n.forEach(function(e,t){if(angular.equals(e,i)){s=t}});return s}return t.index}}]).directive("jqyouiDraggable",["ngDragDropService",function(e){return{require:"?jqyouiDroppable",restrict:"A",link:function(t,n,r){var i,s;var o=function(o,u){if(o){i=t.$eval(n.attr("jqyoui-draggable"))||[];n.draggable({disabled:false}).draggable(t.$eval(r.jqyouiOptions)||{}).draggable({start:function(n,r){s=angular.element(this).css("z-index");angular.element(this).css("z-index",99999);jqyoui.startXY=angular.element(this).offset();e.callEventCallback(t,i.onStart,n,r)},stop:function(n,r){angular.element(this).css("z-index",s);e.callEventCallback(t,i.onStop,n,r)},drag:function(n,r){e.callEventCallback(t,i.onDrag,n,r)}})}else{n.draggable({disabled:true})}};t.$watch(function(){return t.$eval(r.drag)},o);o()}}}]).directive("jqyouiDroppable",["ngDragDropService",function(e){return{restrict:"A",priority:1,link:function(t,n,r){var i=function(i,s){if(i){n.droppable({disabled:false}).droppable(t.$eval(r.jqyouiOptions)||{}).droppable({over:function(n,r){var i=t.$eval(angular.element(this).attr("jqyoui-droppable"))||[];e.callEventCallback(t,i.onOver,n,r)},out:function(n,r){var i=t.$eval(angular.element(this).attr("jqyoui-droppable"))||[];e.callEventCallback(t,i.onOut,n,r)},drop:function(t,n){e.invokeDrop(angular.element(n.draggable),angular.element(this),t,n)}})}else{n.droppable({disabled:true})}};t.$watch(function(){return t.$eval(r.drop)},i);i()}}}])
;
(function() {

    angular.module('dragAndDrop', [])
        .directive( 'drag', function ( dndApi ) {

            var drags = [],
                dragging = new RegExp( '(\\s|^)dragging(\\s|$)' );

            return {
                restrict: 'A',
                scope: {
                    item: '=drag',
                    whenStart : '&',
                    whenEnd : '&'
                },
                link: function ( scope, elem, attr, ctrl ) {

                    elem[0].addEventListener( 'dragstart', function ( e ) {

                        if ( drags.length === 0 ) {
                            drags = document.querySelectorAll( '.drop' );
                        }

                        angular.forEach( drags, function ( value, key ) {
                            angular.element(value).addClass('dragging');
                        } );

                        elem.addClass('on-drag');

                        dndApi.setData(scope.item);

                        e.dataTransfer.effectAllowed = 'move';

                        scope.$apply( function () {
                            scope.whenStart( { data: dndApi.getData() } );
                        } );

                    } );

                    elem[0].addEventListener( 'dragend', function ( e ) {

                        elem.removeClass('on-drag');

                        angular.forEach( drags, function ( value, key ) {
                            value.className = value.className.replace( dragging, '' );
                        } );

                        scope.$apply( function () {
                            scope.whenEnd( { data: dndApi.getData() } );
                        } );

                        dndApi.removeData();

                    } );

                    elem[0].draggable = true;

                    elem[0].className = elem[0].className + ' drag';

                }
            };
        } ).directive( 'drop', function ( dndApi ) {

            var drags = [],
                dragging = new RegExp( '(\\s|^)dragging(\\s|$)');

            return {
                scope: {
                    drop : '=',
                    whenDrop: '&',
                    whenEnter : '&',
                    whenLeave : '&'
                },
                link: function ( scope, elem, attr, ctrl ) {

                    var left = elem[0].offsetLeft,
                        right = left + elem[0].offsetWidth,
                        top = elem[0].offsetTop,
                        bottom = top + elem[0].offsetHeight;


                    elem[0].addEventListener( 'drop', function ( e ) {

                        if(e.stopPropagation()){
                            e.preventDefault();
                        }

                        scope.$apply( function () {
                            scope.whenDrop( { data: dndApi.getData(), target: elem } );
                        } );

                        if ( drags.length === 0 ) {
                            drags = document.querySelectorAll( '.drop' );
                        }

                        angular.forEach( drags, function ( value, key ) {
                            angular.element(value).removeClass('dragging');
                        } );

                        dndApi.removeData();

                    } );

                    elem[0].addEventListener ( 'dragenter', function(e){

                        if(elem[0] === e.target)
                        {
                            scope.$apply( function () {
                                scope.whenEnter( { data: dndApi.getData(), target: elem } );
                            } );
                        }

                    });

                    elem[0].addEventListener ( 'dragleave', function(e){


                        if( (e.x < left || e.x > right) ||
                            (e.y < top  || e.y > bottom) )
                        {
                            scope.$apply( function () {
                                scope.whenLeave( { data: dndApi.getData(), target: elem } );
                            } );
                        }
                    });


                    elem[0].addEventListener ( 'dragover', function ( e ) {

                        if ( e.preventDefault ) {
                            e.preventDefault();
                        }

                        return false;

                    } );


                    elem.addClass('drop');

                }
            };

        } ).factory('dndApi', function(){

            var dnd = {
                dragObject : {}
            };

            return {
                setData : function(data){
                    dnd.dragObject = data;
                },
                removeData : function(){
                    dnd.dragObject = null;
                },
                getData : function(){
                    return dnd.dragObject;
                }
            };
        } );

}());
;
'use strict';

// Data Models

var Maze = function(opts) {

	// private variables
	var MAX_ROWS = 15,
		MIN_ROWS = 4,
		MAX_COLUMNS = MAX_ROWS,
		MIN_COLUMNS = MIN_ROWS,
		startCellSet = false,
		finishCellSet = false;
		// listeners = {};


	// public variables
	this.cells = (opts.cells) || []; // cells stored by rows: ex: [1: [cell, cell, cell, ...]]
	this.rows = (opts.rows) || 7;
	this.columns = (opts.columns) || 7;
	this.animationDuration = (opts.animationDuration) || 600;


	// public functions
	this.addColumn = function() {
		console.log('addColumn');
		if(this.columns < MAX_COLUMNS) {
			this.columns += 1;
			this.resize();
			// this.dispatch('maze:addColumn');
		}
	};

	this.removeColumn = function() {
		console.log('removeColumn');
		if(this.columns > MIN_COLUMNS) {
			this.columns -= 1;
			this.resize();
			// this.dispatch('maze:removeColumn');
		}
	};

	this.addRow = function() {
		console.log('addRow');
		if(this.rows < MAX_ROWS) {
			this.rows += 1;
			this.resize();
			// this.dispatch('maze:addRow');
		}
	};

	this.removeRow = function() {
		console.log('removeRow');
		if(this.rows > MIN_ROWS) {
			this.rows -= 1;
			this.resize();
			// this.dispatch('maze:removeRow');
		}
	};

	this.cellAt = function(row, column) {
		if(typeof this.cells[row][column] !== 'undefined') {
			return this.cells[row][column];
		}
	};

	this.setStart = function(row, column) {
		var cell = this.cellAt(row, column);

		if(cell) {
			cell.type = MazeCellType.START;
			this.startCellSet = true;
		}
	};

	this.setFinish = function(row, column) {
		var cell = this.cellAt(row, column);

		if(cell) {
			cell.type = MazeCellType.FINISH;
			this.finishCellSet = true;
		}
	};

	this.startSet = function() {
		return startCellSet;
	};

	this.finishSet = function() {
		return finishCellSet;
	};

	this.solve = function(animate) {
		var animated = animate || false;

		if(animated) {
			console.log('animate');
		}
	};

	this.resize = function() {
		console.log('resize: ', this.rows, this.columns);

		// console.log('typeof cells: ', typeof this.cells);
		// if(typeof this.cells == )
		// this.cells = [];

		var _cells = [];

		for(var r = 1; r <= this.rows; r++) {
			if(typeof this.cells[r] === 'undefined') {
				this.cells[r] = {};
			}

			_cells[r] = {};

			for(var c = 1; c <= this.columns; c++) {
				// console.log('cell: ', this.cells[r][c]);
				// console.log('cell type: ', typeof this.cells[r][c]);
				//var cell = this.cellAt(r, c);

				if(typeof this.cells[r][c] === 'undefined'){
					_cells[r][c] = new MazeCell(r, c, MazeCellType.PATH); // (Math.floor(Math.random() * 2) + 1));
				}
				else{
					_cells[r][c] = new MazeCell(r, c, this.cells[r][c].type);
				}
			}
		}

		this.cells = _cells;
	};


	// init this object after properties and functions are set
	this.resize();
};

var MazeCell = function(row, column, type) {
	this.row = row;
	this.column = column;
	this.type = type;
};

var MazeCellType = {
	PATH: 1,
	WALL: 2,
	START: 3,
	FINISH: 4,
	SEARCHED: 5,
	SEARCHED_POPPED: 6,
	SOLUTION: 7
};
;
'use strict';

var mazeApp = angular.module('mazeApp', ['dragAndDrop']);

mazeApp.factory('MazeService', function(){
	var currentMaze = new Maze({rows: 7, columns: 7, animationDuration: 600});

	//build service api
	return {
		rows: currentMaze.rows,
		columns: currentMaze.columns,
		cells: currentMaze.cells,
		animationDuration: currentMaze.animationDuration,
		addRow: function() {
			currentMaze.addRow();
			this.mazeChanged();
		},
		removeRow: function() {
			currentMaze.removeRow();
			this.mazeChanged();
		},
		addColumn: function() {
			currentMaze.addColumn();
			this.mazeChanged();
		},
		removeColumn: function() {
			currentMaze.removeColumn();
			this.mazeChanged();
		},
		mazeChanged: function() {
			this.rows = currentMaze.rows;
			this.columns = currentMaze.columns;
			this.cells = currentMaze.cells;
		}
	};
});

mazeApp.controller('MazeCtrl', function($scope, MazeService) {

	var logs = []; //'hi', 'what'];

	$scope.maze = MazeService;
	$scope.logs = logs;
	$scope.draggableCellTypes = [MazeCellType.START, MazeCellType.FINISH];

	$scope.cellClicked = function(cell) {
		// console.log('cell type: ', cell.type);
		this.logs.push('cell clicked: {' + cell.row + ',' + cell.column + '} type: ' + cell.type);
		cell.type = cell.type === 1 ? 2 : 1;
		// cell.type = Math.floor( Math.random() * 4 ) + 1;
		// console.log('cell type: ', cell.type);
	};

	$scope.changeType = function(data) {
		console.log('mazeApp changeType(): ', data);
	};

	$scope.previewCell = function(data) {
		console.log('mazeApp previewCell(): ', data);
	};

	$scope.removeCellPreview = function(data) {
		console.log('mazeApp removeCellPreview(): ', data);
	};
});

mazeApp.directive('mazeSettings', function(MazeService){
	return {
		restrict: 'E',
		scope: false,
		templateUrl: 'view/maze-settings.html',
		controller: function($scope, $element, $attrs, MazeService) {
			$scope.maze = MazeService;

			$scope.$watch('maze', function(){
				$scope.maze = MazeService;
			});
		}
	};
});


